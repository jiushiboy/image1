---
title: 关于我在工作中遇到的一些问题
tags:
  - 关于我
categories:
  - 关于我
abbrlink: f4e286d7
date: 2021-04-10 09:35:35
---
## 参数校验
```java
class JiuShiBoy{
    private String jiushi;
    public String getJiuShi(){
        return jiushi;
    }
    public void setJiuShi(String jiushi){
        this.jiushi=jiushi;
    }
}
public class TestDemo{
    public static void main(String[] args){
        // 1、校验对象中的制定属性 -->支持对象中有List -->支持List遍历和父类遍历
        JiuShiBoy jiushiboy=new JiuShiBoy();
        jiushiboy.setJiuShi("my name is jiushi");
        String args[] = {"jiushi"};
        //校验参数,入参1:你需要检验的参数对象,入参2:你指定校验的参数名
        ParamsUtils.isParamsNotNull(jiushiboy, args);
    }
}

class ParamsUtils{
    //多线程访问共同一个变量的时候容易出问题,所以保证安全使用ThreadLocal对象进行存取操作
    private static ThreadLocal<String> param = new ThreadLocal<>();

    public static void isParamsNotNull(Object obj,String... argsName){
    //将数组转为集合
    List<String> args=Array.asList(argsName);
    try{
        //循环遍历对象中的属性
        for(Field field : obj.getClass.getDeclaredFields()){
            //为true则表示字段为private的也能访问
            f.setAccessible(true);
            //检查参数是否为null
            checkParamsNotNull(args,f,obj,argsName);
        }
        //如果含有父类并且父类不是Object则遍历父类
        if(!obj.getClass.getSuperclass().equals(Object.class)){
           //使用递归,方法自己调用自己
           isParamsNotNull(obj,obj.getClass().getSuperclass(),argsName);
        }
    }catch(Exception e){
        String errorParam=param.get();
        param.remove();
        throw new JiuShiBoyParamException(JiuShiBoyResponseCode.PARAMS_ERROR,"参数:{}不能为空",errorParam);
    }
    
}


    private static void checkParamsNotNull(List<String> args,Field field,Object obj,String... argsName){
        //判断你要判断为null的字段名是否包含当前字段名
        if(args.contains(f.getName())){//包含则进入if
            //f.get(obj)的意思是: 获取obj里面这个字段的值
            if(null==f.get(obj) || "".equals(f.get(obj))){//当获取到了值则可以作非空校验
               //当这个字段值为空,则设置参数为这个字段的属性名
               param.set(f.getName());
               //之后抛出一个自定义的参数异常,JiuShiBoyResponseCode.PARAMS_ERROR 只是自定义的一个枚举
               throw new JiuShiBoyParamException(JiuShiBoyResponseCode.PARAMS_ERROR); 
            }
        }
        //当你要判断的属性值是list集合类型
        if(f.getType().equals(List.class)){
            //循环这个集合
            for(Object o:(List)f.get(obj)){
                //然后调用上面的非空校验方法
                isParamsNotNull(o,argsName);
            }
        }
    }
}
```
> 看完我解释之后的代码可能还有疑问,那么我的枚举定义是什么结构呢?
```
public enum JiuShiBoyResponseCode{
    //当使用了这个枚举以后就相当于定义了状态码,错误信息,成功还是失败
    PARAMS_ERROR("5000","参数异常",false);
    private String status;
    private String message;
    private String success;
    //get set方法我就省略了
}
```
> 那报错以后会出现的效果是什么样子呢?
```
    //当你使用PostMan调用接口,你使用了参数校验但是你没有传值
    {
        "success": false,
        "code": "100003",
        "msg": "参数异常",
        "data": "参数：[platformCode] 不能为空"
    }
```

> 那么我的自定义异常类
```
public class JiuShiBoyParamException extends RuntimeException implements Serializable{
    private static final long serialVersionUID = 1L;
    private JiuShiBoyResponseCode responseCode;
    private String msg;
    
    //为什么我在抛出参数异常的时候写入的是参数:{}不能为空会变成你字段为空的属性名
    public JiuShiBoyParamException(JiuShiBoyResponseCode errorCode,String msg,String... args){
        this.responseCode=errorCode;
        //判断参数中是否为空
        if(args == null || args.length == 0){
            //为空就直接返回原先的错误信息
            this.msg=msg;
        }else{
            StringBuilder sb=new StringBuilder(msg);
            for(String arg:args){
                sb.replace(sb.indexOf("{"),sb.IndexOf("}")+1,new StringBuilder("[").append(arg).append("]").toString());
            }
        }
    }
}
```
## 关于自定义返回值
```
    //通常调用Controller接口时都避免不了状态码、是否成功、返回信息以及数据
    //那么就可以自定义一个对象用来做返回
    class JiuShiRespDto{
        public static <T> ResponseDto<T> JiuShi(boolean isSuccess,Integer status,String massage,T data){
            
        }
    }
    
    class ResponseDto{
        private boolean isSuccess;
        private String status;
        private String massage;
        private T data;
        //省略构造以及get/set
    }
    //当我们在Controller层需要返回时
    class JiuShiController{
        @RquestMapping("/ImTired")
        public ResponseDto ImTired(@RequestBody String str){
            //JiuShiBoy jiushi=xxxxx.get(str);
            //当传入了枚举,枚举中定义了状态码、返回消息、返回成功这时在JiuShi的方法中会有赋值的操作最终返回成一个ResponseDto
            return JiuShiRespDto.JiuShi(JiuShiCode.SUCCESS,str);
        }
    }
    
    enum JiuShiCode{
        SUCCESS(10000,"九世说成功了!",true);
    }
```
## 关于JSON转换
```
    import com.alibaba.fastjson.JSON;
    //注意这里用的是阿里云的fastJson 当然你也可以选择Google的Gson
    class JiuShiTest{
        public static void main(String[] args){
            //集合对象List<JiuSHi>转成json字符串
            String jsonString=JSON.toJSONString(List<JiuShi>);
            //json字符串转集合对象 --> 参数1:需要转换的字符串   参数2:要转换成类型
            List<JiuShi> jiushiList=JSON.parseArray(jsonString,JiuShi.class);
        }
    }
```
## 关于分页
```
    //1.说到分页,肯定得抽取共通的属性
    public class PageEntity{
        // 当前页
        private Integer currentPage;
        // 每页条数
        private Integer pageSize;
        private Integer start;
        private Integer end;
    }
    //2.抽取之后子类继承PageEntity可达到共用的效果
```
## 关于批量
```

    //这里主要讲的是Mybatis的各种批量操作
    //1.批量查询  
    <!--通用的返回结果映射-->
    <resultMap id="JiuShiBaseResultMap" type="com.jiushiboy.entity.JiuShi">
        <result property="jiushi" column="JIUSHI" />
        <result property="boy" column="BOY" />
    </resultMap>
    
    <!-- 通用的查询字段 -->
    <sql id="JiuShiFind">
        JIUSHI,
        BOY
    </sql>
    <select id="queryJiuShiList" resultType="String" resultMap="JiuShiBaseResultMap">
        SELECT <include refid="JiuShiFind" />
        FROM jiushi_table
        WHERE DEL_FLAG = 0
        <if test="list != null and list.size>0 ">
            AND  JIUSHI in
            <foreach collection="list" item="jiushi" index="index"
                     open="(" close=")" separator=",">
                #{jiushi}
            </foreach>
        </if>
    </select>
    
    //2.批量插入
    <insert id="insertAll" parameterType="java.util.List">
        insert into jiushi (
           JIUSHI,
           BOY
        ) values
        <foreach collection="list" item="item" index="index" separator=",">
            <trim prefix="(" suffix=")" suffixOverrides=",">
                #{item.jiushi},
                #{item.boy}
            </trim>
        </foreach>
    </insert>
    
    //3.批量更新
    <update id="batchUpdate" parameterType="java.util.List">
        <foreach collection="list" item="item" index="index" separator=";">
            UPDATE jiushi_table
            <set>
                <if test="item.boy != null">
                    BOY = #{item.boy},
                </if>
            </set>
            WHERE DEL_FLAG = 0
            <if test="item.jiushi != null">
                JIUSHI = #{item.jiushi}
            </if>
        </foreach>
    </update>
```

## 关于在IDEA操作Git时需要将dev分支代码同步到test分支
> ### 1.使用Beyond Compare工具(软件)
> 在两边分别设置dev分支的项目路径和test分支路径
![](https://cdn.jsdelivr.net/gh/jiushiboy/image1/about/20210513102744.png)
> 当开始比较之后文件夹的颜色会发生变化就代码代码不同,这时可以点进代码进行往右移动或者是左
![](https://cdn.jsdelivr.net/gh/jiushiboy/image1/about/20210513103045.png)

> ### 2.使用IDEA中Git操作



## 遇到的一些问题
> ### 使用了BigDecimal接收金额类型
> BigDecimal当你定义了变量而不初始化值去使用则会报空指针异常
```
    // 正确使用方法
    BigDecimal money = BigDecimal.ZERO;
    // 当你初始化值之后使用它的累加方法就不会空指针了
```

> ### 当前端操作是假操作时所带来的问题
```
    //1.假设我要保存数据,数据结构是这样的
    {
      "tableUniqueCode":"唯一编号",
      "name": "九世",
      "age": "未知",
      "listDatas": [
        {
          "fieldUniqueCode":"字段表唯一编号",
          "fieldCode":"字段编号",
          "fieldName":"字段名称"
        }
      ]
    }
    //当我们那这个数据做修改时,如果前端突然在listDatas中添加了一条数据;
    //注意是添加,在修改时做添加的操作,这时候这条新的数据是没有字段表唯一编号的;
    //还有一个要注意的地方,就是这组数据的关系;
    //外层是信息表,信息表这一条数据下,又有多条字段数据;
    //也就是说在listDatas的数据中,其实每一条都会有tableUniqueCode;
    //当字段表存入tableUniqueCode就相当于他们之间有了一个外键关系;
    //解决方案其实就是在更新的时候在字段表把tableUniqueCode编号的数据全部删掉;
    //因为编辑的时候会将数据重新全部带入进来;
    //然后重新进行添加,可以选择批量;
    //但是要注意的是因为是编辑,所以之前的字段数据是会有自己的唯一编号;
    //除非是在编辑时新增的字段数据,否则肯定是有fieldUniqueCode唯一编号的;
    //这时则需要在后端进行校验;
    //当fieldUniqueCode为空,则生成一个唯一编号,也就意味着这条数据是在编辑的时候新增的;
```
### 当我遇到了一个很奇怪的场景
> 下面我来模仿一下业务场景
> 新增方法的json数据
```
// 表设计为,假设你找九世借钱,那么在添加的时候
// 会添加两条记录,price字段要根据priceType金额类型
// 来判断price是什么金额,如果priceType是0
// 那么price就是你实际找九世借了多少钱
// 如果priceType是1那么price就表示你借钱要多少利息
// 因为添加的时候两条数据其实对应的是一个人的,那么rowUniCode就应该公用一个编号
{
  "jiushiboy": [
    {
      "CustomerName": "九世",
      "price": "1000",
      "priceType": "0",
      "rowUniCode": "1111xxxxxxxx",
      "qq":"1450495810"
    },
    {
      "CustomerName": "九世",
      "price": "1000",
      "priceType": "1",
      "rowUniCode": "1111xxxxxxxx",
      "qq":"1450495810"
    }
  ]
}
//那么在查询的时候,我们首先按照qq来查询
//可以查出两条记录,但是传给前端的时候需要整合成一条数据
//这时你会如何去对这个数据进行整合呢?
//查出这个qq下的所有记录
List<JiuShiBoy> jiushi = jiuShiMapper.queryListByQQ("1450495810");
//然后一个qq下对应的所有记录根据rowUniqueCode进行分组
//为什么要分组? 因为qq为条件的意思是有很多人找这个qq号主借钱
//那么这个qq为条件可以查出很多条数据
//但是在添加的时候,我们是一个借钱的人添加数据会添加两条
//所以就需要用到rowUniqueCode 来分辨一个人的两条记录
Map<String,List<JiuShiBoy>> collect = jiushi.stream().collect(Collectors.groupBy(jiushi -> jiushi.getRowUniqueCode()));
//分完组之后那么map里面装的数据就是对应的,某个人的两条数据
//开始循环遍历,因为是按照rowUniqueCode分组那么map的key就是rowUniqueCode
for(String key:collect.keySet()){
    //然后通过分组之后的key获取到rowUniqueCode对应的多条数据
    //这步get操作其实就已经是获取了两条记录
    List<JiuShiBoy> jiushiboy=collect.get(key);
    //之后就可以为所欲为的操作你的数据进行整合了
    //整合已省略
}
```